# Solution1: Bellman Ford's algorithm

To solve a shortest path problem from a single point to other points with in a directed or undirected graph, there exists a lot of algorithms, e.g. Breadth First Search, Bellman Ford's algorithm, Dijkstra's algorithm, etc. 

So we first attampt to solve it with Bellman Ford's algorithm (An detailed explanation to Bellman Ford's Algorithm in CN can be found [here](https://blog.csdn.net/Yaokai_AssultMaster/article/details/88642573)). Bellman Ford's algorithm could solve shortest path problem from a single vertex in a weighed graph in which the edges can have negative weights. However, we have one more constraints here --- we cannot go more for more than `K` intermediate nodes, that means `K+1` edges.  

Hence, on top of the original Bellman Ford algorithm, we first need to restricts the total number of iterations used for update the shortest path which should be, in this case, `K+1` iterations since we can pass at most `K+1` edges. 

Meanwhile, at iteration `i`, the original Bellman Ford's algorithm could have a minimum path stored of distance `i+1`. Since we are looking for path not exceeding `K+1` edges, we have to keep not 1, but two copy of distances. One for the current step `i`, another for the previous step `i-1`, to ensure that all new distances we calculated are at most `i` edges away from the source. Note here we used a two dimensional array `cost` with shape `2*n` for this purpose, in which we will use `cost[0]` and `cost[1]` as current distance and previous step distance alternatively. At the first step, we are using `cost[0]` as the current distance and `cost[1]` as previous cost.  

Another trick we used here is to use `INF = Integer.MAX_VALUE / 2` as the infinite distance used for algorithm initialization. This gives us the convenience of simply update the distance with `cost[curr][flight[1]] = Math.min(cost[curr][flight[1]], cost[pre][flight[0]] + flight[2]);` each time since we do not have to worry about int value overflow when adding a value to `Integer.MAX_VALUE`. And if a final calculated distance is less than `INF`, then it has been updated for sure. 

At the last step we just need to check the updated minimal cost of current iteration to return corresponding value. 

## Time complexity

`O(K*E)` where `K` is the stops allowed and `E` is the number of edges, i.e. flights connecting two cities. 

## Space complexity

`O(n)` where `n` is the total number of cities. 

```Java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[][] cost = new int[2][n];
        int INF = Integer.MAX_VALUE / 2;
        for (int i = 0; i < cost.length; i++) {
            Arrays.fill(cost[i], INF);
            cost[i][src] = 0;
        }
        
        for (int i = 0; i <= K; i++) {
            for (int[] flight : flights) {
                int curr = i & 1, pre = (~i) & 1;
                cost[curr][flight[1]] = Math.min(cost[curr][flight[1]], cost[pre][flight[0]] + flight[2]);
            }
        }
        
        return cost[K & 1][dst] < INF ? cost[K & 1][dst] : -1;
    }
}
```

# Solution2: Dijkstra's Algorithm
