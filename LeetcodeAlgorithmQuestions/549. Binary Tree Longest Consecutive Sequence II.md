# Solution1: Recursively consider longest increasing and decreasing sequence

Compared with [298. Binary Tree Longest Consecutive Sequence](https://github.com/YaokaiYang-assaultmaster/LeetCode/blob/master/LeetcodeAlgorithmQuestions/298.%20Binary%20Tree%20Longest%20Consecutive%20Sequence.md), this question includes more different conditions since it allows for:  
1. both increasing and decreasing order from a follows the parent-child path.  
2. child-parent-child path.  

Hence this question actually contains 2 subproblems to solve:  
1. what is the longest __increasing__ consecutive parent-child path sequence given a `root` node?  
2. what is the longest __decreasing__ consecutive parent-child path sequence given a `root` node? 

Based on the above 2 sub-solution, we know that the longest consecutive sequence for a given `root` is `longest_increasing_sequence + longest_decreasing_sequence` from this `root`. We can simply add up this 2 value because the longest increasing consecutive sequence and longest decreasing consecutive sequence is guaranteed to showed up in different child path (otherwise there will be a contradiction--a child's value cannot be greater than and less than the root's value at the same time).  

If the root's value's value is not consecutive with a child's value, then the length of current sequence is simply 1.  

Time complexity: `O(n)` where `n` is the number of nodes in the tree.  

Space complexity: `O(logn)` on average for the recursion stack since this is a binary tree.  

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int max = 0;
    public int longestConsecutive(TreeNode root) {
        getLongestConsecutive(root);
        return max;
    }
    
    private int[] getLongestConsecutive(TreeNode root) {
        // returns [longest_decreasing_length_from_root, longest_increasing_length_from_root]
        if (root == null) return new int[]{0, 0};
        int[] left = getLongestConsecutive(root.left);
        int[] right = getLongestConsecutive(root.right);
        int dcr = 1, icr = 1;
        if (root.left != null) {
            if (root.left.val == root.val + 1) {
                icr = left[1] + 1;
            }
            if (root.left.val == root.val - 1) {
                dcr = left[0] + 1;
            }
        }
        if (root.right != null) {
            if (root.right.val == root.val + 1) {
                icr = Math.max(icr, right[1] + 1);
            } if (root.right.val == root.val - 1) {
                dcr = Math.max(dcr, right[0] + 1);
            }
        }
        max = Math.max(max, dcr + icr - 1);
        return new int[]{dcr, icr};
    }
}
```

# Solution2: Dijkstra's Algorithm

Similarly, we can make use of another shortest path algorithm for this question --- Dijkstra's algorithm. Dijkstra's algorithm, in essential, is a greedy algorithm. It starts with the same initialization process as Bellman Ford algorithm, that is, overestimating the distance from source to all other nodes, and then iteratively looking for the local shortest path and update the corresponding costs by applying that local shortest path to reach a new node at the end of that path. Hence anytime a new node is reached from source within Dijkstra's algorithm, it is the shortest path from source node to it. 

Meanwhile, one thing we need to keep in mind is that Dijkstra's algorithm does not keep track of the steps taken, either explicitly or implicitly, since it always takes the local shortest path and try to extend from it, without considering it's step length. Hence we need to explicitly store the steps taken for each existing path in the minimum heap used by Dijkstra's algorithm in our implementation. 

The algorithm can be described as following:   
1. Initlalize the algorithm with a minimum heap, in which we put `{src, 0, 0}` representing `{currentNode, currentCost, currentStep}` correspondingly. The minimum heap is sorted based on `currentCost`.   
2. Construct an adjacency list of adjacency matrix based on the input `flights`, aka, edges, for ease of later iteration.  
3. While the minimum heap is not empty, poll the top element from it and go to step 4. Otherwist, end the algorithm with return `-1` since no shortest path from `src` to `dst` is found.    
4. If the `currentStep` in the 3-tuple is greater than `K + 1`, then it has exceeded the limit of `K` stops (i.e. `K+1` edges/steps), we continue without further checking its edges and neighbors. If not, go to step 5.  
5. If `currentNode == dst`, then we return the `currentCost` since this is already the shortest cost from `src` to `dst`, since Dijkstra's algorithm always find the shortest path first. If not, go to step 6.  
6. For each edges (if exists) of `currentNode`, the path to its neighbor `i` should be `weight(currentNode, i) + currentCost`, the step should be `currentStep + 1`. And we will put this record `{i, weight(currentNode, i) + currentCost, currentStep + 1}` into the minimum heap.  

Note here in the code we also keep a `best` HashMap, it will contain the shortest paths from `src` to other nodes. But this is unnecessary in our solution.  

## Time complexity 

`O(E + ElogE)` in the worst case if we only found the shortest path from src to dst at last. Here `E` refers to the number of edges in the graph.  

## Space complexity

`O(E + N + N^2)`. `O(E)` for the minimum heap, `O(N^2)` for the adjacency list, `O(N)` for `best` (not necessary). Here `E` and `N` refers to the number of edges and nodes in the graph respectively. 

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        // minHeap stores 3-tuple, {node, cost, stepsUsed}
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] a1, int[] a2) {
                return a1[1] - a2[1];
            }
        });
        minHeap.offer(new int[]{src, 0, 0});
        Map<Integer, Map<Integer, Integer>> adjList = new HashMap<>();
        for (int[] flight : flights) {
            adjList.computeIfAbsent(flight[0], key -> new HashMap<Integer, Integer>()).put(flight[1], flight[2]);
        }
        
        // Can't constraints the steps here as we have done in Bellman Ford algorithm,
        // since the priority is sorted based on shortest path, so there is no guarantee how much steps
        // we have taken for the shortest path at the top of the heap
        // So we use a map to store the best results
        Map<Integer, Integer> best = new HashMap<>();
        while (!minHeap.isEmpty()) {
            int[] curr = minHeap.poll();
            int end = curr[0], cost = curr[1], step = curr[2];
            if (step > K + 1) continue;
            if (end == dst) return cost;
            if (adjList.containsKey(end)) {
                for (int u : adjList.get(end).keySet()) {
                    int nextCost = cost + adjList.get(end).get(u);
                    if (step <= K) {
                        minHeap.offer(new int[]{u, nextCost, step + 1});
                        best.put(u, Math.min(best.getOrDefault(u, Integer.MAX_VALUE), nextCost));
                    }
                }
            }
        }
        
        return -1;
    }
}
```
