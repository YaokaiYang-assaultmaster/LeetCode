# Solution1: Straightforward Solution

Given that all the numbers are within the range `[1, N]` where `N` is the length of the input, we can have a HashSet to store all the numbers that has appeared within the input array. 

Then we could iterate through all numbers from `1` to `N` and find out the numbers that has not been stored in the HashSet yet, which would be the numbers we are looking for. 

## Time complexity

`O(2*N) = O(N)`. 

## Space complexity

`O(N)` for the extra HashSet. 

```Java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        Set<Integer> existed = new HashSet<>();
        
        List<Integer> list = new ArrayList<>();
        if (nums == null || nums.length == 0) return list;
        
        for (int ele : nums) {
            existed.add(ele);
        }
        
        for (int i = 1; i <= nums.length; i++) {
            if (!existed.contains(i)) {
                list.add(i);
            }
        }
        
        return list;
    }
}
```

# Solution2: Inplace state keeping

In the above solution we used a HashSet for keeping the existence status of the numbers in the array. However, given the condition that all the numbers in the array are within the range `[1, N]`, we can figure out some way to save the extra space used by storing the existence (or not) state of each number in place using the input array. 

How could we do that? Well, we could use the symbol of the numbers in the array. I.e., for `nums[i]`, we could negate the number at index `nums[i]-1` in the `nums` array. The "negating" here at each index is used as the storage for the existence state, as a replacement of the HashSet used in Solution1. 

```Java

```
