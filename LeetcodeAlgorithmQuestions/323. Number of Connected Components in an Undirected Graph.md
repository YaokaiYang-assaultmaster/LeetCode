# Solution1: Union Find

As is indicated by the requirement of the question obviously, this is a dynamic connectivity problem which is suitable to be resolved with Union Find algorithm naturally. 

Here we utilized the optimized version for Union Find algorithm: Weighted Union with path compression. 

```java
class Solution {
    public int countComponents(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }
        
        return uf.getConnectedGraphCount();
    }
    
    class UnionFind {
        int[] id;
        int[] size;
        
        UnionFind(int n) {
            this.id = new int[n];
            this.size = new int[n];
            
            Arrays.fill(size, 1);
            for (int i = 0; i < n; i++) {
                id[i] = i;
            }
        }
        
        void union(int i, int j) {
            int rootI = getRoot(i);
            int rootJ = getRoot(j);
            
            if (rootI == rootJ) return;
            if (size[rootI] > size[rootJ]) {
                id[rootJ] = rootI;
                size[i] += size[j];
            } else {
                id[rootI] = rootJ;
                size[j] += size[i];
            }
        }
        
        boolean find(int i, int j) {
            return getRoot(i) == getRoot(j);
        }
        
        int getRoot(int i) {
            while (id[i] != i) {
                id[i] = id[id[i]];
                i = id[i];
            }
            
            return i;
        }
        
        int getConnectedGraphCount() {
            int count = 0;
            for (int i = 0; i < id.length; i++) {
                if (id[i] == i) {
                    count++;
                }
            }
            
            return count;
        }
    }
}
```

## Time complexity

For a weighted Union with path compression algorithm, the time complexity of unioning `E` edges is `O(E*α(n))` where `α(n)` is the inverse ackermann function that grows exponentially slow. 

## Space complexity

`O(n)` since we used 2 arrays to store the root and size of each vertices.  

# Solution2: DFS

```java
class Solution {
    public int countComponents(int n, int[][] edges) {
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adjList.add(new ArrayList<>());
        }
        
        boolean[] visited = new boolean[n];
        for (int[] edge : edges) {
            adjList.get(edge[0]).add(edge[1]);
            adjList.get(edge[1]).add(edge[0]);
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                count++;
                dfs(i, adjList, visited);
            }
        }
        
        return count;
    }
    
    private void dfs(int curr, List<List<Integer>> adjList, boolean[] visited) {
        visited[curr] = true;
        
        for (int next : adjList.get(curr)) {
            if (!visited[next]) {
                dfs(next, adjList, visited);
            }
        }
    }
}
```
