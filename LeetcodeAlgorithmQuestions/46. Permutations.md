# Solution1: Backtrackng with existance checking

Given an array of integers, all of its permutations can been viewed as a set of trees rooted at each of the numbers inside the array. And each of the permutation array is actually a branch from the root to the leaf. Hence in order to get all of the permutations for the input array we need to traverse all the trees, in which there are a total of `n!` possible combinations. 

For every number of the nums array:  
1.  If it is not already used, add it to the current constructed array and recursively check from the begining of the array again. Once the recursion returns, remove the number, which now locates at the last position of current array.
2. If it is already used, do nothing and continue to the next number in the array.
3. If the size of the current constructed array is the same as the input array, which means that every number in the input array has been added into the current result, we store the current result (note a new array need to be created with this sequence and store, since the current result array is being manupulated in each iteration). 

## Time complexity 

`O(1)` for checking whether a number has been used or not. `O(n!)` possible permutations, thus `O(n!)` in total. 

## Space complexity

`O(n!)` for storing permutations, `O(n)` for the HashSet used for storing used numbers. Hence `O(n!)` in total. 

```java
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ret = new LinkedList<>();
        if (nums == null || nums.length == 0) return ret;
        
        getResult (nums, ret, new LinkedList<Integer>(), new HashSet<Integer>());
        return ret;
    }
    
    private void getResult(int[] nums, List<List<Integer>> ret, List<Integer> curr, Set<Integer> set) {
        if (curr.size() == nums.length) {
            ret.add(new LinkedList<>(curr));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (!set.contains(nums[i])) {
                curr.add(nums[i]);
                set.add(nums[i]);
                getResult(nums, ret, curr, set);
                set.remove(curr.get(curr.size() - 1));
                curr.remove(curr.size() - 1);
            }
        }
    }
}
```

# Solution2: BFS style interpolation

In a level order BFS, we normally remember the size of the current level, and iterate through all of the items in this level before going to next level, while we know which level we are visiting at any time. 

Get back to the tree structure of the permutations mentioned above, a BFS could be used for iterating through all permutations to generate them as well. 

In this case, at each level `i` we only check permutations of length `i`, generated by the first `i` elements of the input array. Given the `i+1`th element in the input array, there are `i+1` possible positions in the existing sub-permutations we can put, that is, position 0 through `i+1` (the end) of them, in a interpolation style. Then we put this new permutation of length `i+1` back to the `ret` list for next level iteration. 

Note there is a little trick used here to solve the time and effort of deleting permutations of previous level from the `ret` list, marked as `Important trick` in the code. We intentionally leave the process of adding current number to the end of each sub-permutation of current level thus we can reuse the existing permutations already stored in the `ret` list. 

## Time complexity

`O(n!)` for iterating each possible permutation.

## Space complexity

`O(n!)` for storing results. `O(1)` for other parts during algorithm runtime. 

```java
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ret = new ArrayList<>();
        List<Integer> curr = new ArrayList<>();
        ret.add(curr);
        
        for (int i = 0; i < nums.length; i++) {
            int len = ret.size();
            for (int x = 0; x < len; x++) {
                List<Integer> perm = ret.get(x);
                for (int j = 0; j < perm.size(); j++) {
                    List<Integer> tmpPerm = new ArrayList<>(perm);
                    tmpPerm.add(j, nums[i]);
                    ret.add(tmpPerm);
                }
                
                // Important trick
                // reuse the permutations which is already stored in the array
                // otherwise we need to remove old permutations from ret and add new ones to it
                // then the for loop above will look something like this:
                // for (int j = 0; i <= perm.size(); j++) {
                //     List<Integer> tmpPerm = new ArrayList<>(perm);
                //     tmpPerm.add(j, nums[i]);
                //     ret.add(tmpPerm);
                // }
                // ret.remove(perm);
                perm.add(nums[i]);
            }
        }
        
        return ret;
    }
}
```

# Solution3: Recursively decide the first element of every subarray

For every length `i` sub array where `i` ranges from `0` to `nums.length-1`, the subproblem could be who should be the first element in the current permutation. 
So we swap the number at the start index with each of the remaining numbers whose index is greater than start.
At this point, the remaining subproblem is to generating permutations with numbers from `start + 1` to the end of the array.
Once start reaches the end of the input, we know we have arrived at a permutation we need. We add it to the ret list. 

## Time complexity

`O(n!)`

## Space complexity
`O(n)` for storing results. `O(n)` for storing all numbers during run time. 

```java
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> permutations = new LinkedList<>();
        if (nums == null || nums.length == 0) return permutations;

        List<Integer> numList = new LinkedList<Integer>();
        for (int n : nums) {
            numList.add(n);
        }
        generatePermutation(numList, 0, permutations);
        return permutations;
    }
    
    private void generatePermutation(List<Integer> numList, int start, List<List<Integer>> ret) {
        if (start >= numList.size()) {
            ret.add(new LinkedList<Integer>(numList)); 
            // Must create a new list and stores it into the ret list. 
            // Since numList is a reference type, if we add it directly into ret, 
            // all of the elements in ret would be just another pointer pointing to the same list which is also pointed by numList. 
        }
        else {
            for (int i = start; i < numList.size(); i++) {
                swap(numList, start, i);
                generatePermutation(numList, start + 1, ret);
                swap(numList, start, i);
            }
        }
    }
    
    private void swap(List<Integer> numList, int p1, int p2) {
        int tmp = numList.get(p1);
        numList.set(p1, numList.get(p2));
        numList.set(p2, tmp);
    }
}
```
